\documentclass[11pt,a4paper,oneside]{mwart}
%cała konfiguracja TeXa
\usepackage[utf8]{inputenc}

\def \MYHEADER {Planowanie działań i~ruchu robotów}
\def \MYTITLE {Wyszukiwanie ścieżki w~labiryncie\\za pomocą algorytmów \\przeszukiwania wszerz \\oraz\\przeszukiwania w~głąb}
\def \MYPDFTITLE {Plan.dzial.i.ruch.rob}

\def \MYPDFDATE {\today}

\def \MYAUTHOR {\emph{Autorzy:}\\Wojciech \textsc{Matkowski}\\Piotr \textsc{Mika}\\Paweł \textsc{Ruciński}}
\def \MYPDFAUTHOR {Piotr Mika}

\def \MYLECTURER {\emph{Prowadzący:} \\dr~in\.z. I.~\textsc{Dulęba}}

\def \MYLSTSETLANGUAGE {c++}

\def \MYLSTSETFRAME {lines}
						%none, %single, 

\def \MYLSTSETKEYWORDS {} 

\input{_cfg_rob.tex}

\begin{document}

\input{_str_tytulowa.tex}


\newpage
\thispagestyle{empty}
~~~~~~~~~~~~~~
\newpage

\setcounter{tocdepth}{3}
\tableofcontents
\newpage

\section{Wstęp}

Robot mobilny, poza możliwością poruszania się musi także mieć umiejętność wybrania swojej trasy.
Ścieżka ta musi gwarantować bezkolizyjność. 
Zwykle też chcemy minimalizować koszty wyrażany np. jako ilość energii potrzebna do przebycia trasy 
lub czas jej pokonania.
W~celu uproszczenia obliczeń oraz zapisania przestrzeni (środowiska) w~postaci cyfrowej przedstawiamy 
otoczenie w~postaci grafu. 
Poszczególne krawędzie grafu oznaczają ścieżki, których przebycie nie niesie za sobą żadnych 
,,niespodzianek''\footnote{Przetworzenie przestrzeni na graf, oraz ustalenie wag krawędzi jest innym 
zadaniem, nie rozpatrywanym w~tej pracy.}.
Oznacza to, że planowanie ścieżki sprowadza się do znalezienia jej w~grafie.

Celem projektu jest stworzenie programu wizualizującego wyszukiwanie ścieżki w~labiryncie -- grafie.

\subsection{Omówienie algorytmów}

Metody przeszukiwania grafów można podzielić na dwie podstawowe grupy: 
przeszukiwania ślepe (ang. \emph{blind search}) oraz przeszukiwania zachłanne i~heurystyczne.

Przeszukiwania ślepe są najprostszymi algorytmami. 
Nie uwzględniają one żadnych zależności dotyczących wag krawędzi.
Takimi algorytmami są \emph{przeszukiwanie w~głąb} oraz \emph{przeszukiwanie wszerz}.

Algorytmy zachłanne i~heurystyczne zwykle znajdują optymalną ścieżkę w~grafie 
(np. alg. Dijkstry), a~używanie heurystyki (np. alg. A*) powoduje zdecydowane przyspieszenie obliczeń.

\subsubsection{Przeszukiwanie wszerz}
W celu znalezienia ścieżki od wierzchołka A~do wierzchołka B~algorytm wykonuje następujące kroki:
\begin{algorithm}
\caption{Przeszukiwanie wszerz}
\label{algorytm_wszerz}
\begin{algorithmic}[1]
\STATE{Dodaj wierzchołek A~do kolejki.}
\WHILE{kolejka nie jest pusta}
	\STATE{Pobierz \underline{pierwszy} wierzchołek z~kolejki.}
	\FORALL{wierzchołków połączonych z~bieżącym}
		\IF{wierzchołek nie był odwiedzony}
			\STATE{Dodaj wierzchołek na \underline{koniec} kolejki.}
		\ENDIF
	\ENDFOR
\ENDWHILE
\end{algorithmic}
\end{algorithm}

Taka metodyka powoduje dotarcie do każdego z~wierzchołków w~grafie, jeśli tylko istnieje ścieżka do niego.
Dodatkowo, jeśli wagi krawędzi są równe to algorytm ten jest równoważny z~algorytmem Dijkstry i~znajduje 
najkrótszą ścieżkę.

\subsubsection{Przeszukiwanie w~głąb}
Algorytm ten jest bardzo zbliżony do przeszukiwania wszerz, jedynie różni się tylko kolejnością pobierania 
wierzchołków z~kolejki.
\begin{algorithm}
\caption{Przeszukiwanie w~głąb}
\label{algorytm_w_glab}
\begin{algorithmic}[1]
\STATE{Dodaj wierzchołek A~do kolejki.}
\WHILE{kolejka nie jest pusta}
	\STATE{Pobierz \underline{ostatni} wierzchołek z~kolejki.}
	\FORALL{wierzchołków połączonych z~bieżącym}
		\IF{wierzchołek nie był odwiedzony}
			\STATE{Dodaj wierzchołek na \underline{koniec} kolejki.}
		\ENDIF
	\ENDFOR
\ENDWHILE
\end{algorithmic}
\end{algorithm}

Powoduje to jednak możliwość wystąpienia sytuacji w~której znaleziona ścieżka będzie dłuższa niż optymalna.

\begin{figure}[!h]
\centering
\framebox{\includegraphics[angle=0,width=0.3\textwidth]{img/petla.png}}
\caption{Ścieżka nieoptymalna znaleziona przeszukiwaniem w~głąb (start -- zielony, stop -- czerwony)\label{petla}}
\end{figure}

\subsection{Typy labiryntów}
Robot porusza się w~przestrzeni dwuwymiarowej z~przeszkodami. 
W~tym projekcie przyjęto metodę nałożenia siatki na przestrzeń. 
Powoduje to powstanie dwóch typów punktów: dozwolonych i~zabronionych. 
Z~punktu dozwolonego można przejść na sąsiadujące z~nim punkty dozwolone.

Labiryntem nazywamy obszar w~którym znalezienie ścieżki (przez człowieka) jest utrudnione.
Zwykle wynika to z~dużej ilości rozwidleń danej ścieżki. 
Rozwidlenia te dodatkowo nie prowadzą do punktu końcowego. 
Typ mapy (labirynt lub nie) nie ma żadnego wpływu na działanie algorytmu, gdyż algorytm w~przeciwieństwie do 
człowieka potrafi zapamiętać dowolnie długa i~skomplikowaną ścieżkę.

\subsubsection{Wpływ grubości ścieżki}
\begin{figure}[!htp]
\begin{center}$
\begin{array}{cp{2cm}c}
\framebox{\includegraphics[angle=0,width=0.3\textwidth]{img/podwojna_g.png}} & &
\framebox{\includegraphics[angle=0,width=0.3\textwidth]{img/podwojna_s.png}}
\end{array}$
\end{center}
\caption{,,Zapętlenie'' przeszukiwania w~głąb (po lewej) w~porównaniu 
do przeszukiwania wszerz(po prawej)\label{podwojna}}
\end{figure}
Badane algorytmy nie uwzględniają grubości ścieżki przechodząc taką ścieżkę kilka razy.
Powoduje to wydłużanie czasu obliczeń, a~w~przypadku przeszukiwania w~głąb znaleziona ścieżka może być
zawinięta.


\section{Realizacja}
Program został napisany w języku \emph{C++} przy użyciu biblioteki \emph{Qt}.
Obrazy są obsługiwane za pomocą klasy \emph{QImage}, a~graficzny interfejs jest zbudowany przy pomocy 
technologii \emph{Qt Widgets}.
\emph{Qt} dostarcza programiście dodatkowe elementy, które rozszerzają język \emph{C++} o nowe mechanizmy.
Są to makra \lstinline!Q_OBJECT! oraz mechanizm sygnałów i~slotów.
Te dodatkowe elementy wymuszają niestandardową kompilację, która jest omówiona 
w~dodatku \ref{sec_uruchomienie}. na stronie \pageref{sec_uruchomienie}.

\lstinline!Q_OBJECT! pozwala rozszerzyć możliwości każdej klasy o dodatkowe, zestandaryzowane mechanizmy
biblioteki \emph{Qt}. Są one potrzebne do lepszego zarządzania pamięcią oraz dla mechanizmu sygnałów i~slotów.

Dzięki sygnałom i~slotom można łączyć dowolne zdarzenia w~programie. 
W~ten sposób obsługiwany jest interfejs użytkownika.
Zdarzenia wywoływane akcjami użytkownika uruchamiają odpowiednie funkcje w klasie opisującej 
główne okno programu. 
Na schemacie \ref{przeplyw}. przedstawiono komunikację wewnątrz programu.

\begin{scheme}[!h]
\centering
\includegraphics[angle=0,width=0.7\textwidth]{img/przeplyw.pdf}
\caption{Przepływ danych i zdarzeń w programie\label{przeplyw}}
\end{scheme}

\section{Wyniki}
Obrazki, wykresy długości kolejek i~ścieżki i~coś tam jeszcze ja zrobię (PM).

\section{Wnioski}
Że działa szybko i~ładnie, że grube ścieżki zabijają przeszukiwanie w~głąb.


\appendix

\section{Uruchomienie aplikacji\label{sec_uruchomienie}}
\begin{figure}[!h]
\centering
\includegraphics[angle=0,width=1\textwidth]{img/gui.png}
\caption{Interfejs programu\label{gui}}
\end{figure}

Po uruchomieniu aplikacji należy wczytać obraz, wybrać typ algorytmu i~określić, 
czy program ma generować plik statystyk.
Pozostałe opcje można ustawiać podczas pracy.

\subsection{Kompilacja ze źródeł}
Kompilację programu najłatwiej przeprowadzić w~środowisku \emph{Qt Creator}. 
Jest ono dostępne dla platform Windows, Linux, Mac i innych.
Po zaimportowaniu projektu używamy przycisku ,,build'' i otrzymujemy gotową aplikację.
Środowisko samo wykona wszystkie etapy kompilacji.
Kompilacja projektu w~\emph{Qt} składa się z kilku etapów: 
\begin{itemize}
\item \textsc{qmake}: na podstawie pliku \emph{*.pro} jest tworzony i uruchamiany plik Makefile, 
w~którym zawarte są kolejne operacje,
\item \textsc{uic}: przetwarza pliki \emph{*.ui} (opisujące interfejs graficzny) na pliki \emph{*.hpp},
\item \textsc{moc}: przetwarza pliki \emph{*.hpp}, rozwijając makra \lstinline!Q_OBJECT! 
oraz generując kod sygnałów i slotów,
\item \textsc{g++}: wygenerowane pliki są kompilowane kompilatorem języka \emph{C++}.
\end{itemize}


\end{document}

